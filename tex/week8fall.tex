\chapter*{Week 8: File I/O}
\addcontentsline{toc}{chapter}{Week 8: File I/O}
\setcounter{chapter}{9}
\setcounter{section}{0}

\begin{abstract}
This week you will:
\begin{enumerate}
    \item Learn how to open file streams
    \item Learn how to read files line by line
    \item Learn how to use get/unget

\end{enumerate}
    
\end{abstract}

\section{Background}
\subsection{File Input/Output}
So far in class, we've been using the \mintinline{c++}{iostream} standard library. This library has provided us with methods like \mintinline{c++}{cin} and \mintinline{c++}{cout}. \mintinline{c++}{cin} is the method that reads from standard input (i.e. in the terminal via the keyboard) and \mintinline{c++}{cout} is for writing to standard output.

In this background section we'll cover file input, which will allow you to read information from a file. To do this, we'll need to include C++'s fstream library, which is short for "file stream".

\subsubsection{Reading Lines From A File}

\textbf{Step 1. Make a stream object.}

Create an object (a variable) of file stream type. If you want to open a file for reading only, then the ifstream object should be used (short for “input file stream”).

\begin{minted}{c++}
// create an input file stream object
ifstream file_input;
\end{minted}

\textbf{Step 2. Open a file.}

Once you have a file stream object, you need to open the file. To do this, use the ifstream object's \mintinline{c++}{open()} method (function), which takes only one parameter: the file name as a string (surrounded by " " if the file name is given directly).

\begin{minted}{c++}
// open myTextFile.txt with the file stream object
file_input.open("myTextFile.txt");
\end{minted}
  
\textbf{Step 3. Checking for open files.}

It is always good practice to check if the file has been opened properly and take an appropriate action if not. To check if a file was successfully opened, you may use the \mintinline{c++}{fail()} or \mintinline{c++}{is_open()} methods.

\mintinline{c++}{fail()}: This method will return a boolean value true if the file failed to open and false otherwise.

\begin{minted}[breaklines=true]{c++}
if (file_input.fail()) // true when file fails to open
{
    cout << "Could not open file." << endl; 
    return -1; // return to terminate the program; -1 to indicate that the program didn't function as expected
}
// do things with the file
\end{minted}

\mintinline{c++}{is_open()}: This method will return a boolean value true if the file has successfully opened and false otherwise.

\begin{minted}[breaklines=true]{c++}
if (file_input.is_open()) // true when file opens sucessfully
{
    // do things with the file
}
else
{
    cout << "Could not open file." << endl;        
}
\end{minted}

\textbf{Step 4. Read lines from the file.}

To read a line from the file, you can use \mintinline{c++}{getline(file_input, line)} which returns true as long as an additional line has been successfully assigned to the variable line. Once no more lines can be read in, getline returns false. So we can set up a while loop where the condition is the call to getline. 

\mintinline{c++}{.eof()}: This method will return a boolean value true if all the data in the file was processed and false otherwise.

\begin{minted}[breaklines=true]{c++}
string line = "";
int line_idx = 0;
// read each line from the file
while (!file_input.eof()) // continue looping as long as there is data to be processed in the file
{
    // get the next line from the file and store in 'line' variable
    getline(file_input, line);

    // print each line read from the file
    cout << line_idx << ": " << line << endl;

    // increment index(count of lines in the file)
    line_idx++;   
}
\end{minted}

\textbf{Step 5. Closing a file.}

When you are finished processing your files, it is recommended to close all the opened files before the program is terminated. You can do this by using the \mintinline{c++}{.close()} function on your file stream object.

\begin{minted}{c++}
// closing the file
file_input.close();
\end{minted}


\textbf{Step 6. Putting it all together.}
If we put all the previous steps together, this is the final piece of code we get.

\begin{minted}[breaklines=true]{c++}
// create an input file stream object
ifstream file_input;

// open myTextFile.txt with the file stream object
file_input.open("myTextFile.txt"); 

// check if file opened successfully
if (file_input.fail())
{
    cout << "Could not open file." << endl;
    return -1;
}
else
{
    // do things with the file
    string line = "";
    int line_idx = 0;

    // read each line from the file
    while (!file_input.eof())
    {
        // gets line of text from file_input, stores it in line
        getline(file_input, line);

        // print each line read from the file
        cout << line_idx << ": " << line << endl;

        // increment index (count of lines in the file)
        line_idx++;   
    }
}

// closing the file
myTextFile.close();
\end{minted}

\section{PreQuiz}

\begin{problem}
    When declaring 2D arrays in C++, it is possible to make one dimension flexible, but the other dimension must remain fixed. Which specific dimension should be hard coded in this scenario? And why is this required?
\end{problem}

\begin{problem}
    How can you access a specific element in a 3D array?
\end{problem}

\begin{problem}
    What is the output of the program below?

\begin{minted}{c++}
#include <iostream>
using namespace std;

void mysteryFunction(int arr[], int size)
{
    int temp = arr[size-1];
    int i = size-1;
    while(i > 0)
    {
       arr[i] = arr[i-1];
       i--;
    }
    arr[0] = temp;
}

int main() 
{
    const int N = 7;
    int myArr[N] = {4, 6, 8, 0, 3, 2, 1};

    mysteryFunction(myArr, N);

    // Display the result
    cout << "The result is: " << endl;
    for (int i = 0; i < N; i++) 
    {
        cout << myArr[i] << " ";
    }

    return 0;
}
\end{minted}
\end{problem}

\begin{problem}
    Consider the following code snippet. What are the values of a, b and c?

\begin{minted}{c++}
const int N=4;
int matrix[N][N] = {{1, 2, 3, 4}, 
                    {5, 6, 7, 8}, 
                    {9, 10, 11, 12}, 
                    {13, 14, 15, 16}};
int a = matrix[0][0] + matrix[1][1] + matrix[2][2] + matrix[3][3];
int b = matrix[0][3] * matrix[3][0];
int c = matrix[2][3];
\end{minted}
\end{problem}

\begin{problem}
    (a) You have seen function tables designed to convey the information in a function on previous assignments. Now, given the code shown in part b of this question, fill in the following table for the \mintinline{c++}{elementWiseProduct()} function
\end{problem}

\begin{longtable}[H]{|p{1.7in}|p{4.0in}|} \hline
        \textbf{Function:} \newline 
        elementWiseProduct(int[][], int[][], int, int) & 
        \\ \hline
        \textbf{Purpose:}  &.\\ \hline
        \textbf{Parameters:} &  
\\ \hline
        \textbf{Return value:} &  .\\ \hline
        \textbf{Error handling/} \newline
        \textbf{Boundary conditions:} & . \\ \hline 
        \textbf{Example:} & 
        \begin{example}

        \end{example}

        \begin{sample}

        \end{sample}
             \\ \hline
\end{longtable}

(b) Write 4 assert statements to test the function after the function call in the given code.

    \begin{minted}{c++}
#include <iostream>
#include <cassert>
using namespace std;

void elementWiseProduct(int a[][3], int b[][3], int row, int col)
{
    for (int i = 0; i < row; i++) 
    {
        for (int j = 0; j < col; j++) 
        {
            a[i][j] = a[i][j] * b[i][j];
        }
    }
}
int main() 
{
    const int N=2;
    const int M=3;

    int matrix1[N][M] = {
        {1,2,3},
        {2,3,1}
    };
    int matrix2[N][M] = {
        {2,3,1},
        {2,3,1}
    };

    // Call the elementWiseProduct function with the two matrices
    elementWiseProduct(matrix1, matrix2, N, M);

    // Display the result matrix
    cout << "The result is: "<< endl;
    for (int i = 0; i < 2; i++) 
    {
        for (int j = 0; j < 3; j++) 
        {
            cout << matrix1[i][j] << " ";
        }
        cout << '\n';
    }

    // include assert statements here
    assert(_________________________________);
    assert(_________________________________);
    assert(_________________________________);
    assert(_________________________________);

    return 0;
}

    \end{minted}

\section{Recitation}

\subsection{Spot The Error}
\begin{multipart}
The program below intends to prints average of the scores. Identify the error(s) in the code below, and write the correct line(s).
\end{multipart}

\begin{minted}{c++}
    #include <iostream>
    #include <string> 
    using namespace std;
    int main()
    {
        int size = 6;
        double scores[size] = {85.4, 90.3, 100, 89, 74.5, 95.0, 82.3};
        double sum = 0;
        for(int i = 0; i < size; i++)
        {
            sum += scores[i];
        }
        int avg = sum / 6.0;
        cout << "Average = " << avg << endl;
        return 0; 
    }
\end{minted}

\begin{multipart}
The program below displays transpose of a given matrix. The transpose of a matrix is simply a flipped version of the original matrix by switching its rows with its columns. Identify the error(s) in the code below, and write the correct line(s).
\end{multipart}

\begin{minted}{c++}
    #include <iostream>
    using namespace std;
    
    // Function to calculate the transpose of a matrix
    double transposeMatrix(int matrix[][3], int n, int m) 
    { 
        for (int i = 0; i < n; i++)
        {
            for (int j = i + 1; j < m; j++)
            {
                temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        return matrix;
    } 
    
    int main() 
    {
        const int rows = 3;
        const int cols = 3;
        int originalMatrix[rows][cols] = 
        {
            {1, 1, 1},
            {2, 2, 2},
            {3, 3, 3}
        };
    
        // Calculate the transpose matrix using the function
        int result[rows][cols] = transposeMatrix(originalMatrix[3][3], rows, cols);
    
        // Display the transpose matrix
        cout << "Transpose Matrix:" << endl;
        for (int i = 0; i < rows; i++) 
        {
            for (int j = 0; j < cols; j++) 
            {
                cout << result[i][j] << " ";
            }
            cout << endl;
        }
    
        return 0;
    }
\end{minted}

\begin{multipart}
The program below tries to print all the items specified in the item array. Identify the error(s) in the code below, and write the correct line(s).
\end{multipart}

\begin{minted}{c++}
    #include <iostream>
    using namespace std;
    
    int main()
    {
        int N = 3;
        char item[] = {"book", "pen", "pencil", "eraser"};
    
        //printing all the items
        for (int i = 0; i < N; i++)
        {
            cout << "The item list has " << items[j] << endl;
        }
        return 0;
    }
\end{minted}

\begin{multipart}
The program below prints the strings that have length equal to 4. Identify the error(s) in the code below, and write the correct line(s).
\end{multipart}

\begin{minted}{c++}
    #include <iostream>
    #include <string>
    using namespace std;
    
    int main() 
    {
        const int N = 6;
        string animals[N] = {"lion", "cat", "bear", "dog", "elephant", "fox"};
        for (int i = 0; i < N; i++) 
        {
            if (animals.length()[i] == 4)
            {
                cout << animals[i] << endl;
            }
        }
        return 0;
    }
\end{minted}

\subsection{Coding Telephone}

For this activity, you will need to break into groups of approximately 6-8. The basic idea of the game is simple: We will give you some starting piece of code, with a short region of the code marked for "Coding Telephone". The first person in your group will have to translate the code entirely to comments, leaving no actual code in that region behind. They will pass this comment file on to the second person in your group, who will translate the comments back into code. Then the next person will translate the code to comments, so on and so forth until everyone in your group has participated. Then you will attempt to compile your code and run it, and see what happens. Think of it like the game Telephone, but with code.

You will get the starting code from Canvas. The only person who should view this original code is the first person in your group. Make sure to keep the code secret at each stage so others cannot see it. You will each have five minutes to translate your code. During the time you are not coding, you are welcome to work on the other questions in this recitation assignment. 

Once your group has completed the game, work together to answer the following questions:

\begin{multipart}
    Did your final code compile? If not, what error did it fail with? If this is an easy to fix error, fix it and move on to the next question.
\end{multipart}

\vspace{6cm}

\begin{multipart}
    If your code compiled, did it run? If not, what error did it fail with? If so, what did it print?
\end{multipart}

\vspace{6cm}

\begin{multipart}
    Compile and run the original code, and compare it with the code you ended with. How did it change? Where were some areas of miscommunication? 
\end{multipart}

\vspace{6cm}

\textbf{Submit your answers to these questions along with your final Telephone code for this problem on Canvas.}

%Can we get USBs from the department for this? Do students even know how to use USBs anymore, or would it be faster to have them email it to each other?


\subsection{Matrix Sum}
The sum of two matrices is found by adding together corresponding entries in each matrix, as shown above. (For example, the numbers at (row 1, column 1) of each matrix are added together to get the (row 1, column 1) number of the sum matrix.)

Write a function that accepts two 2x3 integer arrays as input parameters and displays the sum matrix (displayed in 2 rows). Example header:

\mintinline{c++}{void matrixSum(int a[2][3], int b[2][3])}

Then, create a main() function that asks the user to input the values for each matrix one row at a time. Store these in two arrays, and pass them to matrixSum. Example output (red is user input)

\begin{sample}
Enter values for matrix 1, one row at a time:\\
\textcolor{red}{1 2 3}\\
\textcolor{red}{4 5 6}\\
Enter values for matrix 2, one row at a time:\\
\textcolor{red}{2 4 6}\\
\textcolor{red}{8 10 12}\\
The sum is:\\
3 6 9\\
12 15 18\\
\end{sample}

\begin{multipart}
    Write out the steps you would use to solve this problem by hand as pseudocode. 
\end{multipart}

\newpage

\begin{multipart}
Pick possible inputs for your program. Choose as many inputs as you think you need to thoroughly test your program. Follow the steps you wrote for these values to find your result, and verify it.
\end{multipart}

\vspace{14cm}

\begin{multipart}
Implement your solution in C++ using VS Code. Revise your solution, save, compile and run it again. Are you getting the expected result and output? Keep revising until you do. Make you sure you test for the values used in your sample runs, and for the boundary conditions.
\end{multipart}

\section{Homework}

\textbf{Warning: You are not allowed to use global variables for this project.}

All function names, return types, and parameters must precisely match those shown. You may not use pass by reference or otherwise modify the function prototypes. You are welcome to create additional functions that may help streamline your code. 

\subsection{Most Popular Word}

A word is said to be most popular if it occurs more frequently than any other word. Write a function named \mintinline{c++}{mostPopularWord()} that finds the most popular word in an array and prints the word, its frequency, and the indices where it was found. You may assume there's always one correct answer, and the array will be non-empty. If it has equal occurrence, then we always consider the most recent one.

Note: You do not need sorting to solve this.

% \textbf{Function:} Print the word with the highest frequency, its count, and its index positions in the array
% \begin{quote}
% \begin{itemize}
%     \item \textbf{Name:} \mintinline{c++}{MostPopularWord()}
%     \item \textbf{Parameters (your function should accept these parameters IN THIS ORDER):}
%         \begin{itemize}
%             \item \mintinline{c++}{arr} String array: array of words.
%             \item \mintinline{c++}{arrSize} int: The number of elements stored in the array
%         \end{itemize}
%     \item \textbf{Return Value:} void
% \end{itemize}
% \end{quote}


\newpage
\begin{longtable}[H]{|p{1.7in}|p{4.0in}|} \hline
        \textbf{Function:} mostPopularWord(string[], const int) & \mintinline{c++}{void mostPopularWord(string words[], const int WORDS_SIZE)}
        \\ \hline
        \textbf{Purpose:}  & Print the word with the highest frequency, its count, and its index positions in the array.\\ \hline
        \textbf{Parameters:} &  
        \textbf{string} \texttt{words}: Array of words \newline
        \textbf{const int} \texttt{WORDS\_SIZE}: The size of word array
\\ \hline
        \textbf{Return value:} & - The function should print the word with the highest frequency, its count, and its index positions in the array. \newline
        - The function doesn't return any value to the main function. \\ \hline
\textbf{Error Handling/ Boundary Conditions:} &  - If two or more words have the same frequency, the word that appears last will be considered the most popular; see sample run 4.1.3. 
\newline
- You may assume the words[] array is always non-empty. 
\\ \hline
        \textbf{Example:} & 
        \begin{example}
        \begin{minted}[breaklines=true]{c++}

// Assume the proper libraries are included
// Assume the proper implementation of mostPopularWord() is included

int main()
{
    const int WORDS_SIZE = 4;
    string words[WORDS_SIZE] = {"mail", "text", "spam", "spam"};
    mostPopularWord(words, WORDS_SIZE);
    return 0;
}
        \end{minted}
        \end{example}

        \begin{sample}
The most popular word: spam \newline
Frequency: 2 \newline
Found at pos: 2 3 \newline
        \end{sample}
             \\ \hline
\end{longtable}

\textbf{For Question 1, develop and validate your solution in VS Code. Once you are happy with your solution, go to coderunner on Canvas and paste mostPopularWord() and any helper function(s) to the answer box!} 

\begin{sample}
    \textcolor{red}{Test code:}
    \begin{minted}{c++}
    const int WORDS_SIZE = 5;
    string words[WORDS_SIZE] = {"hello", "world", "hello", "world", "hello"};

\end{minted}
\textcolor{red}{Output:}

The most popular word: hello

Frequency: 3

Found at pos: 0 2 4

\end{sample}

\begin{sample}
\textcolor{red}{Test code:}
    \begin{minted}{c++}
    const int WORDS_SIZE = 5;
    string words[WORDS_SIZE] = {"apple", "corn", "corn", "apple", "lettuce"};

\end{minted}
\textcolor{red}{Output:}

The most popular word: apple

Frequency: 2

Found at pos: 0 3


\textcolor{red}{Explanation:}

The last word that appeared with a frequency of 2 is "apple" at index 3. Therefore, based on our rules, that is the word that will be displayed. 
\end{sample}


\subsection{Fitness Statistics}

Bob recently started a daily fitness routine to improve his overall health. Every day, he tracks the number of steps he takes, and after a few weeks of consistent effort, he now wants to analyze his data to gain some insights into his progress. 

To help him, Bob needs two(2) functions written in C++ that will allow him to understand his fitness journey better.

\newline
\textbf{Function 1:} Bob is curious about how his total step count has increased over time. This function will calculate the cumulative sum of his daily step count, showing him the total distance he's covered since he started tracking.
\begin{longtable}[H]{|p{1.7in}|p{4.0in}|} \hline
        \textbf{Function:} \newline 
        stepCountCumulativeSum( int[], const int, int[]) & \mintinline[breaklines=true]{c++}{void stepCountCumulativeSum(int daily_steps[], const int NUM_DAYS, int cumulative_steps[])}
        \\ \hline
        \textbf{Purpose:}  & Calculates the cumulative sum of the daily step counts and records the running total in the cumulative\_steps array. The cumulative sum represents the total number of steps Bob has taken up to each respective day, providing a running total of his overall progress. The function should not print anything.\\ \hline
        \textbf{Parameters:} &  
        \textbf{int} \texttt{daily\_steps[]}: array of Bob's daily step count. \newline
        \textbf{const int} \texttt{NUM\_DAYS}: Size of daily\_steps array and cumulative\_steps array\newline
        \textbf{int} \texttt{cumulative\_steps[]}: Array to be filled with Bob's cumulative step count.
\\ \hline
        \textbf{Return value:} &  The function doesn't return any value. \newline 
        \\ \hline
        \textbf{Example:} & 
        \begin{example}
        \begin{minted}[breaklines=true]{c++}

// Assume the proper libraries are included
// Assume the proper implementation of stepCountCumulativeSum() is included

int main()
{
    const int NUM_DAYS = 5;
    int daily_steps[NUM_DAYS] = {5000, 4000, 5000, 2000, 4000};
    int cumulative_steps[NUM_DAYS];
    stepCountCumulativeSum(daily_steps, NUM_DAYS, cumulative_steps);
    // We are printing the contents of the cumulative_steps array here.
    return 0;
}
        \end{minted}
        \end{example}

        \begin{sample}
5000\newline
9000\newline
14000\newline
16000\newline
20000
        \end{sample}
             \\ \hline
\end{longtable}

\begin{sample}
\textcolor{red}{Test code:}
\begin{minted}{c++}
const int NUM_DAYS = 3;
int daily_steps[NUM_DAYS] = {10000, 2000, 6000};
int cumulative_steps[NUM_DAYS];
\end{minted}
\textcolor{red}{Output:}
\begin{minted}{c++}
10000
12000
18000
\end{minted}
\end{sample}

\begin{sample}
\textcolor{red}{Test code:}
\begin{minted}[breaklines=true]{c++}
const int NUM_DAYS = 4;
int daily_steps[NUM_DAYS] = {4000, 2000, 8000, 3000};
int cumulative_steps[NUM_DAYS];
\end{minted}
\textcolor{red}{Output:}
\begin{minted}{c++}
4000
6000
14000
17000
\end{minted}
\end{sample}

\textbf{Function 2:} Bob is also interested in how consistent he has been with his daily steps. This function will calculate the mean of his daily step count and return the deviation, showing him which days he was above or below his regular activity level.
\begin{longtable}[H]{|p{1.7in}|p{4.0in}|} \hline
        \textbf{Function:} \newline 
        stepCountDeviation( int[], const int, const int) & \mintinline[breaklines=true]{c++}{double stepCountDeviation(int daily_steps[], const int NUM_DAYS, const int OPTIMAL_STEP_COUNT)}
        \\ \hline
        \textbf{Purpose:}  & Calculates the mean of daily step counts and returns the deviation
deviation =  mean - optimal step count \newline
The function should not print anything.

\\ \hline
        \textbf{Parameters:} &  
        \textbf{int} \texttt{daily\_steps[]}: array of Bob's daily step count. \newline
        \textbf{const int} \texttt{NUM\_DAYS}: Size of daily\_steps array\newline
        \textbf{const int} \texttt{OPTIMAL\_STEP\_COUNT}: Desired step count per day.
\\ \hline
        \textbf{Return value:} &  The function will return a \mintinline{c++}{double}, which is the calculated deviation \newline 

\\ \hline
        \textbf{Example:} & 
        \begin{example}
        \begin{minted}[breaklines=true]{c++}

// Assume the proper libraries are included
// Assume the proper implementation of stepCountDeviation() is included

int main()
{
    const int NUM_DAYS = 5;
    int daily_steps[NUM_DAYS] = {5000, 4000, 5000, 2000, 4000};
    const int OPTIMAL_STEP_COUNT = 5000;
    double deviation = stepCountDeviation(daily_steps, NUM_DAYS, OPTIMAL_STEP_COUNT);
    // We are printing the deviation up to 3 decimal places
    cout << fixed << setprecision(3) << deviation << endl;
    return 0;
}
        \end{minted}
        \end{example}

        \begin{sample}
-1000.000
        \end{sample}
        Explanation: mean = (5000 + 4000 + 5000 + 2000 + 4000)/5 = 4000 \newline 
deviation = mean - OPTIMAL\_STEP\_COUNT = 4000 - 5000 = -1000
             \\ \hline
\end{longtable}

\textbf{For Question 2, develop and validate your solution in VS Code. Once you are happy with your solution, go to coderunner on Canvas and paste stepCountCumulativeSum(),  stepCountDeviation(), and any helper function(s) to the answer box!} 

\begin{sample}
\textcolor{red}{Test code:}
\begin{minted}{c++}
const int NUM_DAYS = 3;
int daily_steps[NUM_DAYS] = {10000, 2000, 6000};
const int OPTIMAL_STEP_COUNT = 5000;
\end{minted}
\textcolor{red}{Output:}
\begin{minted}{c++}
1000.000
\end{minted}
\end{sample}

\begin{sample}
\textcolor{red}{Test code:}
\begin{minted}[breaklines=true]{c++}
const int NUM_DAYS = 4;
int daily_steps[NUM_DAYS] = {4000, 2000, 8000, 3000};
const int OPTIMAL_STEP_COUNT = 750;
\end{minted}
\textcolor{red}{Output:}
\begin{minted}{c++}
3500.000
\end{minted}
\end{sample}

\subsection{Normal Heart Rate}

As a pediatrician, you need to monitor newborns' heart rates, which should fall between 70 and 190 bpm. To simplify this task, write a function printNormalHeartRates() that takes two arrays: one with patient names and another with their heart rates. The function will print the names of patients with normal heart rates.

\begin{longtable}[H]{|p{1.7in}|p{4.0in}|} \hline
        \textbf{Function:} \newline 
        printNormalHeartRates (string, int, int) & \mintinline[breaklines=true]{c++}{void printNormalHeartRates(string patients[], int heart_rate[], const int NUM_PATIENTS)}
        \\ \hline
        \textbf{Purpose:}  & Prints out the patients with normal heart rates. Where normal heart rate is between 70 and 190, both inclusive. You may assume that both patients[] and heart\_rate[] arrays will be the same size. \\ \hline
        \textbf{Parameters:} &  
        \textbf{string} \texttt{patients[]}: Array of strings which contains the patient's names. \newline
        \textbf{int} \texttt{heart\_rate[]}: Array of int which contains their heart rate \newline
        \textbf{const int} \texttt{NUM\_PATIENTS}: An integer that gives the number of elements in the patient and heart rate arrays
\\ \hline
        \textbf{Return value:} &  
        - The function doesn't return any value.\newline 
        - Your function should print out all patients whose heart rate is within the range\\ \hline
         \textbf{Error handling/ Boundary conditions:} &  
         - You may assume that the patients[] array and heart\_rate[] array are non-empty\newline 
        - You may also assume that the size of the patients[] array and heart\_rate[] array are always equal\\ \hline
        \textbf{Example:} & 
        \begin{example}
        \begin{minted}[breaklines=true]{c++}

// Assume the proper libraries are included
// Assume the proper implementation of printNormalHeartRates() is included

int main() 
{
    
    string patients[3] = {"Jamie", "Sebastien", "Shaun"};
    int heart_rate[3] = {90, 70, -12};
    
    printNormalHeartRates(patients, heart_rate, 3);
        
    return 0;
}
        \end{minted}
        \end{example}

        \begin{sample}

Jamie 90 \newline
Sebastien 70 \newline
        \end{sample}
             \\ \hline
\end{longtable}

\textbf{For Question 3, develop and validate your solution in VS Code. Once you are happy with your solution, go to coderunner on Canvas and paste printNormalHeartRates() and any helper function(s) to the answer box!} 
\begin{sample}
\textcolor{red}{Test code:}
\begin{minted}{c++}
string patients[4] = {"Joe", "Jack", "Amy", "Bob"};
int heart_rate[4] = {70, 80, 190, 100};
printNormalHeartRates(patients, heart_rate, 4);
\end{minted}
\textcolor{red}{Output:}
\begin{minted}{c++}
Jack 80
Amy 190
Bob 100
\end{minted}
\end{sample}

\begin{sample}
\textcolor{red}{Test code:}
\begin{minted}[breaklines=true]{c++}
string patients[6] = {"Chloe Kim", "Rene Rinnekangas", "Shaun White", "A", "B", "C"};
int heart_rate[6] = {190, 70, 191, 69, 71, 189};
printNormalHeartRates(patients, heart_rate, 6);
\end{minted}
\textcolor{red}{Output:}
\begin{minted}{c++}
Chloe Kim 190
Rene Rinnekangas 70
B 71
C 189
\end{minted}
\end{sample}

\subsection{Best Time to Buy and Sell a House}

Flipping is a real estate strategy that involves buying homes and selling them for a profit in a short period of time. You want to maximize your profit by choosing a single day to buy a house and choosing a different day in the future to sell that house.


\begin{longtable}[H]{|p{1.7in}|p{4.0in}|} \hline
        \textbf{Function:} \newline 
        maxProfit(int[], const int) & \mintinline[breaklines=true]{c++}{int maxProfit(int prices[], const int NUM_MONTHS)}
        \\ \hline
        \textbf{Purpose:}  & Find the maximum profit achieved from buying and selling a house. The function should not print anything. \\ \hline
        \textbf{Parameters:} &  
        \textbf{int} \texttt{prices[]}: Array of prices of the house every month \newline
        \textbf{const int} \texttt{NUM\_MONTHS}: The size of prices array
\\ \hline
        \textbf{Return value:} &  It should return the maximum profit achieved through one house flip. \\ \hline
        \textbf{Error handling/} \newline
        \textbf{Boundary conditions:} & - Return 0 if no profit can be achieved. 
        \newline - You may assume that the \texttt{prices[]} array is always non-empty
        \\ \hline 
        \textbf{Example:} & 
        \begin{example}
        \begin{minted}[breaklines=true, frame = none]{c++}
        
// Assume the proper libraries are included
// Assume the proper implementation of maxProfit() is included

int main()
{
    const int NUM_MONTHS = 6;
    int prices[NUM_MONTHS] = {700000, 100000, 500000, 300000, 600000, 400000};
    int profit = maxProfit(prices, NUM_MONTHS);
    cout << "Maximum profit: " << profit << endl;
    return 0;
}
        \end{minted}
        \end{example}

        \begin{sample}
Maximum Profit: 500000
        \end{sample}

        \textcolor{red}{Explanation:} 
        
        Buy on month 2 (price = 100000) and sell on month 5 (price = 600000), profit = 600000-100000 = 500000.
\newline Note: Buying on month 2 and selling on month 1 is not allowed because you must buy before you sell.

             \\ \hline
\end{longtable}

\textbf{For Question 4, develop and validate your solution in VS Code. Once you are happy with your solution, go to coderunner on Canvas and paste maxProfit() and any helper function(s) to the answer box!}  
\begin{sample}
\textcolor{red}{Test code:}
\begin{minted}{c++}
const int NUM_MONTHS = 5;
int prices[NUM_MONTHS] = {700000, 600000, 400000, 300000, 100000};
\end{minted}
\textcolor{red}{Output:}
\begin{minted}{c++}
Maximum Profit: 0
\end{minted}
\textcolor{red}{Explanation:} 

In this case, no profitable transactions are possible, and the max profit = 0.
\end{sample}


\begin{sample}
\textcolor{red}{Test code:}
\begin{minted}[breaklines=true]{c++}
const int NUM_MONTHS = 6;
int prices[NUM_MONTHS] = {700000, 300000, 400000, 100000, 400000, 100000};
\end{minted}
\textcolor{red}{Output:}
\begin{minted}{c++}
Maximum Profit: 300000
\end{minted}
\textcolor{red}{Explanation:} 

Buy on month 4 (price = 100000) and sell on month 5 (price = 400000), profit = 400000-100000 = 300000.
\end{sample}



\subsection{Splitting a String}

When you're processing data, it's useful to break up a text string into pieces using a delimiter. Write a function split() that takes a string, splits it at every occurrence of a delimiter, and then populates an array of strings with the split pieces, up to the provided maximum number of pieces.

\newpage
\begin{longtable}[H]{|p{1.7in}|p{4.0in}|} \hline
        \textbf{Function:} \newline 
        split(string, char, string[], const int) & \mintinline[breaklines=true]{c++}{int split(string input_string, char separator, string arr[], const int ARR_SIZE)}
        \\ \hline
        \textbf{Purpose:}  & Break a text string into pieces using the given delimiter and populate each piece in the array. The function does not print anything.\\ \hline
        \textbf{Parameters:} &  
        \textbf{string} \texttt{input\_string}: The text string containing data separated by a delimiter \newline
        \textbf{char} \texttt{separator}: The delimiter marking the location where the string should be split up\newline
        \textbf{string} \texttt{arr[]}: The array that will be used to store the input text string's individual string pieces\newline
        \textbf{const int} \texttt{ARR\_SIZE}: The number of elements that can be stored in the array
\\ \hline
        \textbf{Return value:} &  
        - The function returns an \mintinline{c++}{int}, the number of pieces the input text string is split into. 
        \newline
        - Populate \mintinline{c++}{arr[]} with the all the element.
\\ \hline
        \textbf{Error Handling/ Boundary Conditions:} & - Return 1 if the delimiter character is not found. Place the entire string in the array as the first element
        \newline
        - Return -1 if the string is split into more pieces than the size of the array. Fill the array with as many pieces of the split string as possible. \newline
        - Return 0 if an empty string is provided.
        \\ \hline
        \textbf{Example:} & 
               
        \begin{example} 
        \begin{minted}[breaklines=true, frame=none]{c++}

// Assume the proper libraries are included
// Assume the proper implementation of split() is included

void printArray(string arr[], const int NUM_ELEMENTS)
{
    for (int i=0; i < NUM_ELEMENTS; i++)
    {
        cout << "arr["<< i << "]:" << arr[i] << endl;
    }   
}

int main()
{
    string input_string = "ABCDEFG";
    char separator = ' ';
    const int ARR_SIZE = 3;
    string arr[ARR_SIZE];
    // num_splits is the value returned by split
    int num_splits = split(input_string, separator, arr, ARR_SIZE);
    cout << "Function returned value: " << num_splits << endl;
    if(num_splits != -1) 
    {
        printArray(arr, num_splits); 
    } 
    else 
    {
        printArray(arr, ARR_SIZE);
    }
}

        \end{minted}
                \end{example} 

\\ \hline
        \textbf{Sample Run:} &  
        \begin{sample}
Function returned value: 1

arr[0]:ABCDEFG
        \end{sample}

             \\ \hline
\end{longtable}


\textbf{For Question 5, develop and validate your solution in VS Code. Once you are happy with your solution, go to coderunner on Canvas and paste split() and any helper function(s) to the answer box!}

\begin{sample}
\textcolor{red}{Test code:}
\begin{minted}{c++}
string testcase = "RST,UVW,XYZ";
char separator = ',';
const int ARR_SIZE = 3;
string arr[ARR_SIZE];
// num_splits is the value returned by split
int num_splits = split(testcase, separator, arr, ARR_SIZE);
cout << "Function returned value: " << num_splits << endl;
for (int i=0; i < ARR_SIZE; i++){
  cout << "arr["<< i << "]:" << arr[i] << endl;
}
\end{minted}
\textcolor{red}{Output:}
\begin{minted}{c++}
Function returned value: 3
arr[0]:RST
arr[1]:UVW
arr[2]:XYZ
\end{minted}
\end{sample}

\begin{sample}
\textcolor{red}{Test code:}
\begin{minted}[breaklines=true]{c++}
string testcase = "Bangkok,Berlin,Birmingham,Bogota,Busan,Baton Rouge,Beaumont,Boise,Budapest";
char separator = ',';
const int ARR_SIZE = 5;
string arr[ARR_SIZE];
// num_splits is the value returned by split
int num_splits = split(testcase, separator, arr, ARR_SIZE);
cout << "Function returned value: " << num_splits << endl;
for (int i=0; i < ARR_SIZE; i++){
  cout << "arr["<< i << "]:" << arr[i] << endl;
}
\end{minted}
\textcolor{red}{Output:}
\begin{minted}{c++}
Function returned value: -1
arr[0]:Bangkok
arr[1]:Berlin
arr[2]:Birmingham
arr[3]:Bogota
arr[4]:Busan
\end{minted}

\textcolor{red}{Explanation:}

The string can be split into more pieces than the size of the array; thus, we returned -1 and filled the array with as many pieces as possible.

\end{sample}

\subsection{School Exam Scores}

You’re helping your teacher analyze student exam scores across 10 subjects. Each row represents a student’s scores in these subjects. Your task is to identify the first student whose average score falls below a defined threshold. Write a function minAverg() that returns the index of the first student with an average score below the threshold.

\newpage
\begin{longtable}[H]{|p{1.7in}|p{4.0in}|} \hline
        \textbf{Function:} \newline 
        minAverg(int, int, double) & \mintinline[breaklines=true]{c++}{int minAverg(int scores[][10], const int NUM_STUDENTS, double threshold)}
        \\ \hline
        \textbf{Purpose:}  & A function to return the index of a student whose average score is less than or equal to the threshold.\\ \hline
        \textbf{Parameters:} &  
        \textbf{int} \texttt{scores[][10]}: A 2D integer array with 10 columns for storing the scores for each of the 10 subjects \newline
        \textbf{const int} \texttt{NUM\_STUDENTS}: An integer number of rows for each student \newline
        \textbf{double} \texttt{threshold}: A floating number threshold for low average score. 
\\ \hline
        \textbf{Return value:} &  The function returns an \mintinline{c++}{int} representing the index of the first student with a low average score that is less than or equal to the threshold. \\ \hline
        \textbf{Error handling/
Boundary conditions:} &  
- The function returns -1 if there is no average score that is less than or equal to the threshold \newline 
- You may assume that the score[] array is non-empty
\\ \hline
        \textbf{Example:} & 
        \begin{example}
        \begin{minted}[breaklines=true]{c++}

// Assume the proper libraries are included
// Assume the proper implementation of minAverg() is included

int main()
{
    int scores[2][10] = {
         {80, 90, 85, 95, 88, 82, 75, 89, 91, 87},  
         {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}          
    };
    cout << "returned student index: " <<  minAverg(scores, 2, 10.0);
    return 0;
}
        \end{minted}
        \end{example}

        \begin{sample}
returned student index: 1
        \end{sample}
             \\ \hline
\end{longtable}

\textbf{For Question 6, develop and validate your solution in VS Code. Once you are happy with your solution, go to coderunner on Canvas and paste minAverg() and any helper function(s) to the answer box!} 

% Develop and validate your solution in VS Code. Once you are happy with your solution, go to coderunner on Canvas and paste the whole program into the answer box! 
\begin{sample}
\textcolor{red}{Test code:}
\begin{minted}{c++}
int scores[3][10] = {
      {10, 1, 1, 1, 1, 1, 1, 1, 1, 1},
      {2, 2, 2, 2, 2, 2, 2, 2, 2, 20},  
      {3, 3, 3, 3, 3, 30, 3, 3, 3, 3}
};
cout << "returned student index: " <<  minAverg(scores, 2, 25);
\end{minted}
\textcolor{red}{Output:}
\begin{minted}{c++}
returned student index: 0
\end{minted}
\end{sample}

\begin{sample}
\textcolor{red}{Test code:}
\begin{minted}[breaklines=true]{c++}
    int scores[4][10] = {
    {50, 60, 55, 65, 70, 60, 58, 62, 55, 65}, 
    {70, 80, 75, 85, 90, 65, 78, 82, 88, 74},
    {10, 20, 15, 25, 12, 30, 18, 22, 17, 15},  
    {100, 110, 105, 115, 120, 90, 108, 102, 114, 104},
};
cout << "returned student index: " <<  minAverg(scores, 5, 40);
\end{minted}
\textcolor{red}{Output:}
\begin{minted}{c++}
returned student index: 2
\end{minted}
\end{sample}

\begin{sample}
\textcolor{red}{Test code:}
\begin{minted}[breaklines=true]{c++}
int scores[5][10] = { 
    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
    { 1, 1, 10, 1, 1, 1, 1, 1, 1, 1 },
    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 },
    { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }
};
cout << "returned student index: " << minAverg(scores, 5, 9);
\end{minted}
\textcolor{red}{Output:}
\begin{minted}{c++}
returned student index: 0
\end{minted}
\end{sample}













% \subsection{Super Bowl Watch Party}

% Your family loves the Super Bowl. Every year, your family hosts three watch parties: your grandparents have one at their house, your parents have one at their house, and your uncle has one at his house. You and your friends all want to watch the event together, but you are all in different locations. You want to figure out how far each individual is from each of the watch parties. You are given two arrays of coordinates; one array shows the city coordinates of the watch parties, and one shows the coordinates of your friends.


% \begin{table}[H]
%     \centering
%     \begin{tabular}{|c|c|c|}
%     \hline
%          Watch Party City Locations& x& y\\ \hline
%     City 1& 2& 10
% \\ \hline
%     City 2& 5& 8
% \\ \hline
%     City 3& 1& 2\\\hline
%     \end{tabular}
% \end{table}

% \begin{table}[H]
%     \centering
%     \begin{tabular}{|c|c|c|}
%     \hline
%          Individual Locations& x& y
% \\ \hline
%     Person 1& 2& 10
% \\ \hline
%     Person 2& 2& 5
% \\ \hline
%     Person 3& 8& 4
% \\ \hline
%     Person 4& 5& 8\\ \hline
%     Person 5& 1& 2\\ \hline
%     \end{tabular}
% \end{table}
% You want to fill in a table of distances between the watch parties and your friends. This requires comparing the location of a particular watch party ($p2$ in the below equation) with the location of a particular friend ($p1$ in the below equation):

% $distance(p1, p2) = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}$

% These distances will then be used to fill a table of all the distances. From the above input coordinates, the distance matrix obtained is:

% \begin{table}[H]
%     \centering
%     \begin{tabular}{|c|c|c|c|}
%     \hline
%          & City 1 & City 2 & City 3 \\ \hline
%     Person 1 & 0.00 & 3.61 & 8.06 \\ \hline
%     Person 2 & 5.00 & 4.24 & 3.16 \\ \hline
%     Person 3 & 8.49 & 5.00 & 7.28 \\ \hline
%     Person 4 & 3.61 & 0.00 & 7.21 \\ \hline
%     Person 5 & 8.06 & 7.21 & 0.00 \\ \hline
%     \end{tabular}
% \end{table}
% The first value is calculated as $d(person1, city1) = \sqrt{(2 - 2)^2 + (10 - 10)^2} = 0.00$

% The second value is calculated as $d(person1, city2) = \sqrt{(5 - 2)^2 + (8 - 10)^2} = 3.61$ and so on. 

% Function specifications
% \begin{longtable}[H]{|p{1.7in}|p{4.0in}|} \hline
%         \textbf{Function:} \newline 
%         \mintinline[breaklines=true]{c++}{calculateDistanceMatrix( double[], double[], double[],  const int,  const int,  const int,  const int)} & \mintinline[breaklines=true]{c++}{void calculateDistanceMatrix( double distance[][3], double individual_locations[][2], double city_locations[][2], const int I_ROWS,  const int I_COLS,  const int C_ROWS,  const int C_COLS)}
%         \\ \hline
%         \textbf{Purpose:}  & Constructs the distance matrix using individual locations and city locations.\\ \hline
%         \textbf{Parameters:} &  \mintinline{c++}{double distance[][3]}: Empty distance matrix of size I\_ROWS x C\_ROWS. \newline
%         \mintinline{c++}{double individual_locations[][2]}: Coordinates for clues of size I\_ROWS x I\_COLS \newline
%         \mintinline{c++}{double city_locations[][2]}: Coordinates for regions of size C\_ROWS x C\_COLS\newline
%         \mintinline{c++}{const int I_ROWS}:  Number of rows for individual\_locations[][]\newline
%         \mintinline{c++}{const int I_COLS}: Number of columns for individual\_locations[][], will be 2 for this question.\newline
%         \mintinline{c++}{const int C_ROWS}: Number of rows for city\_locations[][], will be 3 for this question.\newline
%         \mintinline{c++}{const int C_COLS}: Number of columns for city\_locations[][], will be 2 for this question.
% \\ \hline
%         \textbf{Return value:} &  The function doesn't return any value. \newline 
%        The function should not print anything. \newline
%        The function fills out the distance matrix using individual locations and city locations. \\ \hline
%         \textbf{Example:} & 
%         \begin{example}
%         \begin{minted}[breaklines=true]{c++}

% // Assume the proper libraries are included
% // Assume the proper implementation of calculateDistanceMatrix() is included

% int main()
% {
%     const int I_ROWS = 5;
%     const int I_COLS = 2;
%     const int C_ROWS = 3;
%     const int C_COLS = 2;
%     double individual_locations[I_ROWS][I_COLS] = {{2, 10}, {2, 5}, {8, 4}, {5, 8}, {1, 2}};
%     double city_locations[C_ROWS][C_COLS] = {{2, 10}, {5, 8}, {1, 2}};
%     double distance[I_ROWS][C_ROWS];
%     calculateDistanceMatrix(distance, individual_locations, city_locations, I_ROWS, I_COLS, C_ROWS, C_COLS);
%     for (int i = 0; i < I_ROWS; i++)
%     {
%         for (int j = 0; j < C_ROWS; j++)
%         {
%             cout << fixed << setprecision(2) << distance[i][j] << " ";
%         }
%         cout << endl;
%     }
%     return 0;
% }
%         \end{minted}
%         \end{example}

%         \begin{sample}
% 0.00	3.61	8.06 \newline
% 5.00	4.24	3.16 \newline
% 8.49	5.00	7.28 \newline
% 3.61	0.00	7.21 \newline
% 8.06	7.21	0.00
%         \end{sample}
%              \\ \hline
% \end{longtable}


% Develop and validate your solution in VS Code. Once you are happy with your solution, go to coderunner on Canvas and paste the whole program into the answer box! 
% \begin{sample}
% Test code:
% \begin{minted}{c++}
% const int I_ROWS = 3;
% const int I_COLS = 2;
% const int C_ROWS = 3;
% const int C_COLS = 2;
% double individual_locations[I_ROWS][I_COLS] = {{2, 10}, {8, 4}, {5, 8}};
% double city_locations[C_ROWS][C_COLS] = {{2, 10}, {5, 8}, {1, 2}};
% double distance[I_ROWS][C_ROWS];
% \end{minted}
% Output:
% \begin{minted}{c++}
% 0.00 3.61 8.06
% 8.49 5.00 7.28
% 3.61 0.00 7.21
% \end{minted}
% \end{sample}

% \begin{sample}
% Test code:
% \begin{minted}[breaklines=true]{c++}
% const int I_ROWS = 4;
% const int I_COLS = 2;
% const int C_ROWS = 3;
% const int C_COLS = 2;
% double individual_locations[I_ROWS][I_COLS] = {{2, 1}, {2, 3}, {4, 4}, {5, 8}};
% double city_locations[C_ROWS][C_COLS] = {{1, 2}, {3, 6}, {5, 8}};
% double distance[I_ROWS][C_ROWS];
% \end{minted}
% Output:
% \begin{minted}{c++}
% 1.41 5.10 7.62
% 1.41 3.16 5.83
% 3.61 2.24 4.12
% 7.21 2.83 0.00
% \end{minted}
% \end{sample}

% \begin{sample}
% Test code:
% \begin{minted}[breaklines=true]{c++}
% const int I_ROWS = 5;
% const int I_COLS = 2;
% const int C_ROWS = 3;
% const int C_COLS = 2;
% double individual_locations[I_ROWS][I_COLS] = {{2, 10}, {2, 5}, {8, 4}, {5, 8}, {1, 2}};
% double city_locations[C_ROWS][C_COLS] = {{0, 0}, {5, -1}, {-1, -2}};
% double distance[I_ROWS][C_ROWS];
% \end{minted}
% Output:
% \begin{minted}{c++}
% 10.20 11.40 12.37
% 5.39 6.71 7.62
% 8.94 5.83 10.82
% 9.43 9.00 11.66
% 2.24 5.00 4.47
% \end{minted}
% \end{sample}